이제 Claude-Sonnet-3.5 모델이 Cursor 등에서 독립 파일로 실행할 수 있도록 전문 형태의 작업지시서를 총 6개 마크다운 파일로 분리해 작성하겠습니다. 각 지시서는 예시가 아닌 완성된 명령 형식으로 구성되며, 외부 참고가 필요한 경우 명확한 GitHub, Reddit, 블로그 링크를 명시합니다.

또한 현재 GitHub 리포지토리의 의존성 문제 및 설치 오류 가능성을 검토한 후, 가장 먼저 실행해야 할 '환경 구성 및 의존성 설치 검증' 작업지시서를 별도 작성하여 Claude가 정확히 시작할 수 있도록 안내하겠습니다. 이 과정이 완료되면 전체 작업지시서와 구조를 정리하여 전달드리겠습니다.


## 01\_docs\_structure.md

# 1. 문서 구조 정리 및 자동화 동기화

**목적 및 개요:** 프로젝트 `docs/` 디렉토리를 정돈하여 **중복되거나 불필요한 문서들을 제거 및 통합**하고, 문서 구조를 체계화합니다. 팔란티어 프로젝트와 무관한 임시 파일(예: 다른 서비스의 Q\&A나 광고 가이드 등)을 삭제하고, 같은 내용을 담은 파일들(`API.md` vs `api.md` 등)은 최신 정보로 병합합니다. 또한 **코드베이스와 불일치하는 오래된 설명**을 최신 상태에 맞게 업데이트하고, 필요하다면 **코드로부터 문서를 자동 생성/동기화하는 도구**를 도입합니다. 이 작업을 통해 문서가 **실제 코드와 일치**하여, 에이전트나 개발자가 참조할 때 혼동을 줄이고 이해도를 높입니다.

**전체 실행 절차:**

1. **불필요한 문서 식별 및 제거:** `docs/` 폴더 내 프로젝트와 무관한 파일을 찾아 삭제합니다. 예를 들어 팔란티어 기능과 관련 없는 **외부 서비스 Q\&A**(`Q&A.md` 내 Baidu OCR 오류 Q\&A 등)나 **타 플랫폼 가이드**(`ads.md` 내 Pi Network 광고 통합 가이드 등)를 제거합니다. 이러한 문서는 프로젝트 기능에 직접 영향이 없으므로 과감히 정리합니다.

   * 또한, 임시로 생성된 문서들 (예: 테스트 출력이나 미사용 설계 초안 등이 `.md`로 남아있는 경우)도 삭제 대상입니다. 삭제 전 해당 파일들이 **코드 내에서 참조되고 있지 않은지** (`grep` 등으로 파일명 검색) 확인하여, 참조되지 않는다면 안전하게 제거합니다.

2. **중복 및 유사 문서 통합:** 내용이 중복되거나 겹치는 문서들을 비교 분석하여 **하나의 최신 문서로 합칩**니다.

   * 예를 들어 대소문자만 다른 `API.md` vs `api.md` 파일이 있다면 두 파일 내용을 모두 확인하여 가장 최신 정보로 **단일 `API.md`** 파일을 만들고, 다른 하나는 삭제합니다.
   * 마찬가지로 `NEWS.md`, `News.md`, `NEWS_OLD.md` 등 과거 릴리즈 노트나 변경사항 문서가 여러 버전 존재하면, 최신 정보 위주로 합쳐 **하나의 NEWS.md**만 남기고 나머지는 제거합니다. (혹은 `CHANGELOG.md` 등 표준화된 이름으로 통합하는 것도 고려합니다.)
   * 문서 내용을 통합할 때 변경 이력이나 중요한 차이점이 있다면, 최신 문서에 해당 내용을 반영하고 주석으로 보존할지 판단합니다.

3. **문서 구조 체계화:** 남은 유용한 문서들을 주제별로 **재분류**합니다. 예를 들어 **설치 및 환경설정 가이드**, **API 사용법**, **시스템 아키텍처 설계**, **FAQ** 등으로 카테고리를 나눠 폴더 구조를 정리합니다.

   * `docs/` 폴더 내에 `installation/`, `api/`, `architecture/`, `guides/` 등의 하위 디렉토리를 만들고 문서들을 이동시킵니다. (예: `INSTALL.md`나 환경 설정 내용은 `installation/README.md`로, API 관련 문서는 `api/` 폴더로 이동 등)
   * **목차 파일 업데이트:** 문서 구조가 변경되었다면, `docs/SUMMARY.md`나 README의 문서 링크 목록을 최신 구조에 맞게 고칩니다. MkDocs나 GitBook 등을 쓰고 있다면 구성 파일(`mkdocs.yml` 등)을 수정하여 새 폴더 구조를 반영합니다.
   * 문서 파일명도 일관성 있게 정합니다. 가능하면 영문 단어와 짧은 설명으로 짓고, 대소문자는 통일합니다 (예: 모두 대문자 시작 혹은 소문자). 이렇게 하면 파일시스템 및 배포 환경에서의 혼란을 줄일 수 있습니다.

4. **코드-문서 불일치 내용 수정:** 문서에 서술된 내용 중 현재 코드와 맞지 않는 부분을 찾아 업데이트합니다. 예를 들어, 문서에 "**API 요청 URL은 `/v1/xyz`이다**"라고 적혀 있는데 실제 코드에서는 `/api/v2/xyz`로 변경되었다면 이를 수정합니다. 이러한 불일치를 찾기 위해 **프로젝트 코드를 grep**하여 문서에 언급된 클래스명, 함수명, 엔드포인트 등을 확인합니다.

   * 예: 문서의 코드 조각이 오래되어 실행이 안 되는 경우, 실제 코드에 맞춰 고쳐주거나 해당 부분을 제거하고 "**(구현 변경으로 인한 업데이트 필요)**" 등의 표시를 해 둡니다.
   * 또한, 새로운 기능이 코드에 추가되었지만 문서에 언급되지 않았다면, 관련 문서 섹션을 추가해 간략히 설명을 보완합니다. (예: 새로운 환경변수, 새로운 API 엔드포인트의 목적 등)

5. **문서 자동화 동기화 도구 도입 (선택):** 문서와 코드의 **동기화**를 지속적으로 유지하기 위해, 일부 문서는 **코드로부터 자동 생성되거나 검증**되도록 체계를 마련합니다. 예를 들어:

   * **데이터 모델 문서화:** Pydantic 모델이나 SQLAlchemy 모델을 사용한다면, 해당 모델 정의로부터 JSON Schema나 마이그레이션 다이어그램 등을 자동 생성하는 스크립트를 추가합니다. 이를 CI에 포함시켜 **코드 업데이트 시 문서도 자동 갱신**되게 합니다.
   * **API 스펙 문서화:** FastAPI를 사용 중이면 `app.openapi()`를 호출해 OpenAPI 스펙(json)을 추출하고, 이를 기반으로 한 문서를 제공하거나 (Swagger UI는 자동으로 제공되지만) 정적 마크다운 문서를 생성해 `docs/api_reference.md`로 저장할 수 있습니다.
   * **주석 기반 문서화:** 함수나 클래스에 docstring을 충분히 작성하고, Sphinx나 MkDocs의 자동 문서화 기능을 활용해 개발 문서를 생성하도록 합니다.

**실행 지침:** 위의 절차에 따라 문서를 정리할 때, **파일 삭제나 이동은 Git 버전관리 하에서 진행**하여 추적 가능하도록 합니다. 불필요 문서를 제거한 후 커밋 메세지에 "Remove deprecated docs" 등의 기록을 남기고, 병합/통합한 경우 "Merge API.md and api.md"처럼 명시합니다.

### 📄 예시: Pydantic 모델 기반 자동 문서 스키마 생성

아래 코드는 **Pydantic** 모델 정의로부터 JSON Schema를 추출해 문서화에 활용하는 방법을 보여줍니다. 이 스크립트를 활용하면 데이터 모델의 변경사항을 손쉽게 문서에 반영할 수 있습니다 (예: 필드 추가/수정 시 JSON Schema도 업데이트). Palantir AIP의 *“실시간 문서 생성”* 기능과 유사하게, **코드 구조를 기반으로 문서를 자동 생성/동기화**하는 접근입니다. (FastAPI 환경이라면, Pydantic 모델로부터 **자동 생성되는 OpenAPI 문서**도 적극 활용 가능합니다.)

```python
# docs_schema.py - Using Pydantic to auto-generate JSON schema documentation

from pydantic import BaseModel

# 예시 모델 정의 (실제 프로젝트의 데이터 모델로 교체 가능)
class User(BaseModel):
    id: int
    name: str
    age: int

# JSON Schema 생성 및 파일로 저장
schema_json = User.schema_json(indent=2)
with open("docs/User_schema.json", "w") as f:
    f.write(schema_json)

# 단위 테스트: 생성된 JSON 스키마에 모델 필드들이 포함돼 있는지 확인
assert '"title": "User"' in schema_json, "Schema title missing!"
assert '"properties": {' in schema_json, "Schema properties not generated"
assert '"name"' in schema_json and '"age"' in schema_json, "Fields missing in schema"

# Expected output: docs/User_schema.json 파일이 생성되고, 내부에 "id", "name", "age" 등의 필드 정보를 포함한 JSON Schema가 기록됨.
```

위 코드에서는 `User`라는 Pydantic 모델에 대해 `schema_json()` 메서드로 JSON Schema를 추출한 후 파일로 저장합니다. 이러한 JSON Schema는 API 문서나 데이터 스키마 설명서의 기반으로 활용될 수 있습니다. 이를 프로젝트 CI 파이프라인에 포함시키면, **모델이 변경될 때마다 최신 스키마를 문서로 자동 반영**할 수 있습니다. FastAPI를 사용한다면 코드에서 자동 생성되는 문서 (예: Swagger UI나 Redoc) 역시 최신 상태의 API 명세를 보여주므로, README 등에서 해당 링크를 제공하는 것도 좋은 전략입니다.

**오류 발생 시 대처:**

* **문서 파일 잠재적 누락:** 파일을 이동/삭제한 후에는 혹시 **코드에서 해당 파일을 열거나 참조**하는 부분이 없는지 확인해야 합니다. 예를 들어 코드에서 특정 markdown 파일을 읽어 응답에 사용하고 있었다면 (특정 안내문 등을) 파일 제거 시 코드도 수정이 필요합니다. 이런 부분을 간과하면 FileNotFound 에러가 발생할 수 있으니, `git grep "파일명"`으로 전역 검색하여 참조 여부를 점검합니다.
* **권한 문제:** 문서 폴더 정리 과정에서 운영체제의 파일 권한 문제로 삭제가 안 되는 경우, 파일 속성을 확인하고 필요하다면 `chmod`로 권한을 조정하거나 관리자 권한으로 시도합니다.
* **자동화 도구 설정:** Sphinx/MkDocs 등을 도입하는 경우, 초기 설정이나 경로 이슈로 문서 생성이 실패할 수 있습니다. `conf.py`(Sphinx 설정)나 `mkdocs.yml` 등의 설정 파일에서 경로를 올바르게 지정하고, 의존 패키지(`sphinx`, `mkdocs`, 플러그인 등)를 `pip install`했는지 확인합니다. 또한 자동화 도구가 너무 오래된 docstring 형식을 요구한다면 최신 표준에 맞게 주석을 업데이트합니다.

문서 폴더가 정리되고 나면, **프로젝트에 대한 신뢰성 있는 정보 소스**가 확보됩니다. 이제 AI 에이전트나 신규 투입된 개발자가 문서를 참고할 때 혼동이 줄고, 코드와 문서의 싱크가 맞아 유지보수 효율이 높아집니다. 다음으로 **AIP 시스템 (LLM 연동) 기능을 점검 및 구현**하는 작업을 진행합니다.

---
